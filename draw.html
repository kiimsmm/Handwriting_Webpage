<!-- draw.html -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>직접 손글씨 쓰기</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        html, body {
            overscroll-behavior: contain;  /* 펜 스크롤 튐 방지 */
            user-select: none;             /* 텍스트 선택 방지 */
        }
        canvas {
            touch-action: none;            /* 캔버스 위 제스처 무력화 */
            border: 2px dashed #ced4da;
            border-radius: 10px;
        }
    </style>
</head>
<body class="bg-light text-center">
<nav class="navbar navbar-expand-lg" style="background-color: #002147;">
    <div class="container-fluid justify-content-center py-2">
        <span class="navbar-brand text-white fw-bold fs-3 mb-0">FontHacker</span>
    </div>
</nav>

<div class="container py-5">
    <h2 id="stepTitle" class="mb-3">A를 써주세요</h2>

    <div class="d-flex justify-content-center">
        <canvas id="canvasOne" width="1600" height="360" style="width: 1600px; height: 360px;"></canvas>
    </div>

    <div class="d-flex justify-content-center gap-2 mt-3">
        <button class="btn btn-outline-secondary btn-sm" onclick="clearCanvas('canvasOne')">지우기</button>
        <button id="nextBtn" class="btn btn-primary" onclick="captureAndNext()">다음(B)</button>
        <button id="submitBtn" class="btn btn-success" onclick="submitSingleFlow()" disabled>제출</button>
    </div>
</div>

<script>

    function applyDpiScale(canvas) {
        const dpr = window.devicePixelRatio || 1;
        const cssW = parseInt(getComputedStyle(canvas).width, 10);
        const cssH = parseInt(getComputedStyle(canvas).height, 10);
        canvas.width  = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        const ctx = canvas.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function enableDrawing(canvasId) {
        const canvas = document.getElementById(canvasId);
        const ctx = canvas.getContext("2d");

        // 초기 흰 배경
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 민감도 파라미터
        const MIN_PRESSURE = 0.10;
        const DEADZONE_PX  = 1.0;
        const SMOOTHING    = 0.25;
        const CONTACT_MS   = 30;
        const MIN_LINE_W   = 2;
        const MAX_LINE_W   = 6;

        let drawing = false;
        let confirming = false;
        let confirmTimer = null;
        let lastX = 0, lastY = 0;

        canvas.addEventListener("contextmenu", e => e.preventDefault());

        canvas.addEventListener("pointerdown", (e) => {
            if (e.target !== canvas) return;
            if (e.pointerType !== 'pen') return;
            if (!(e.buttons & 1) || e.button !== 0) return;
            if ((e.pressure || 0) < MIN_PRESSURE) return;

            e.preventDefault(); // 제스처 차단
            canvas.setPointerCapture?.(e.pointerId);

            const r = canvas.getBoundingClientRect();
            lastX = e.clientX - r.left;
            lastY = e.clientY - r.top;

            confirming = true;
            confirmTimer = window.setTimeout(() => {
                if ((e.buttons & 1) && (e.pressure || 0) >= MIN_PRESSURE) {
                    drawing = true;
                }
                confirming = false;
            }, CONTACT_MS);
        }, { passive: false });   // ← 중요

        canvas.addEventListener("pointermove", (e) => {
            if (e.target !== canvas) return;
            if (e.pointerType !== 'pen') return;
            e.preventDefault();

            const r = canvas.getBoundingClientRect();
            let x = e.clientX - r.left;
            let y = e.clientY - r.top;

            if (confirming) {
                if (!(e.buttons & 1) || (e.pressure || 0) < MIN_PRESSURE) {
                    window.clearTimeout(confirmTimer);
                    confirming = false;
                }
                return;
            }

            if (!drawing) return;
            if (!(e.buttons & 1) || (e.pressure || 0) < MIN_PRESSURE) return;

            const dx = x - lastX, dy = y - lastY;
            if (Math.hypot(dx, dy) < DEADZONE_PX) return;

            x = lastX + (x - lastX) * (1 - SMOOTHING);
            y = lastY + (y - lastY) * (1 - SMOOTHING);

            const p = Math.max(MIN_PRESSURE, Math.min(1, e.pressure || 0.5));
            const w = MIN_LINE_W + (MAX_LINE_W - MIN_LINE_W) * p;

            ctx.lineWidth = w;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.strokeStyle = "#000";

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();

            lastX = x; lastY = y;
        }, { passive: false });   // ← 중요

        const endStroke = (e) => {
            if (confirming) {
                window.clearTimeout(confirmTimer);
                confirming = false;
            }
            if (drawing) {
                try { canvas.releasePointerCapture?.(e.pointerId); } catch {}
            }
            drawing = false;
        };
        canvas.addEventListener("pointerup", endStroke, { passive: false });
        canvas.addEventListener("pointercancel", endStroke, { passive: false });
        canvas.addEventListener("pointerleave", endStroke, { passive: false });
    }

    function clearCanvas(id) {
        const canvas = document.getElementById(id);
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // 흰 배경 + 흑백 변환 후 DataURL
    function canvasToWhiteGrayDataURL(canvas) {
        const off = document.createElement("canvas");
        off.width = canvas.width;
        off.height = canvas.height;
        const octx = off.getContext("2d");

        octx.fillStyle = "#ffffff";
        octx.fillRect(0, 0, off.width, off.height);
        octx.drawImage(canvas, 0, 0);

        const imgData = octx.getImageData(0, 0, off.width, off.height);
        const data = imgData.data;
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i], g = data[i+1], b = data[i+2];
            const gray = 0.299*r + 0.587*g + 0.114*b;
            data[i] = data[i+1] = data[i+2] = gray;
        }
        octx.putImageData(imgData, 0, 0);

        return off.toDataURL("image/png");
    }

    let currentStep = 'A';
    let capturedA = null; // DataURL 저장

    // A 또는 B 캡처 후 다음 단계/제출
    function captureAndNext() {
        const c = document.getElementById('canvasOne');
        const data = canvasToWhiteGrayDataURL(c);

        if (currentStep === 'A') {
            capturedA = data;
            // 캔버스 초기화
            clearCanvas('canvasOne');
            // 라벨 변경
            document.getElementById('stepTitle').innerText = 'B를 써주세요';
            // 버튼 상태
            document.getElementById('nextBtn').classList.replace('btn-primary','btn-secondary');
            document.getElementById('nextBtn').setAttribute('disabled', 'disabled'); // B는 한 번만 캡처하도록
            document.getElementById('submitBtn').removeAttribute('disabled');
            currentStep = 'B';
        }
    }

    // 최종 제출 (A= capturedA, B= 현재 캔버스)
    function submitSingleFlow() {
        const c = document.getElementById('canvasOne');
        const dataB = canvasToWhiteGrayDataURL(c);

        // 스토리지 저장(기존 result.html 흐름 재사용)
        localStorage.setItem("handwritingImageA", capturedA);
        localStorage.setItem("handwritingImageB", dataB);

        window.location.href = "result.html";
    }

    const canvas = document.getElementById('canvasOne');
    applyDpiScale(canvas);
    enableDrawing('canvasOne');

</script>
</body>
</html>
